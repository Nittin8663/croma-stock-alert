import requests
from bs4 import BeautifulSoup
import time
import random
import json

def check_product_stock(url, product_name):
    # More comprehensive headers to mimic a real browser
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'Referer': 'https://www.croma.com/',
        'sec-ch-ua': '"Not.A/Brand";v="8", "Chromium";v="114", "Google Chrome";v="114"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"',
        'sec-fetch-dest': 'document',
        'sec-fetch-mode': 'navigate',
        'sec-fetch-site': 'same-origin',
        'sec-fetch-user': '?1',
        'upgrade-insecure-requests': '1',
        'cache-control': 'max-age=0',
        'Connection': 'keep-alive',
    }
    
    # Add cookies (optional, but helps with some sites)
    cookies = {
        'visitorId': f'visitor-{random.randint(1000000, 9999999)}',
        'sessionId': f'session-{random.randint(1000000, 9999999)}',
    }
    
    try:
        # Add a small delay to avoid triggering rate limits
        time.sleep(random.uniform(1, 3))
        
        # Make the request with a longer timeout
        response = requests.get(
            url, 
            headers=headers, 
            cookies=cookies,
            timeout=15,
            allow_redirects=True
        )
        
        # Save the HTML response for debugging
        with open(f"{product_name.replace(' ', '_')}_response.html", "w", encoding="utf-8") as f:
            f.write(response.text)
        
        # Check if we're getting the actual product page
        if response.status_code == 200:
            print(f"Successfully accessed page for {product_name}")
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Check for page title to see if we're on the right page
            title = soup.title.text if soup.title else "No title"
            print(f"Page title: {title}")
            
            # Try different ways to check stock status
            
            # Method 1: Look for specific text indicating out of stock
            out_of_stock_indicators = [
                'out of stock',
                'sold out',
                'currently unavailable',
                'coming soon'
            ]
            
            page_text = soup.get_text().lower()
            for indicator in out_of_stock_indicators:
                if indicator in page_text:
                    print(f"❌ {product_name} is OUT OF STOCK (found '{indicator}')")
                    return False
            
            # Method 2: Look for the Add to Cart button
            add_to_cart_buttons = soup.select('button[data-testid="add-to-cart"], .pdp-button, .buy-button')
            if add_to_cart_buttons:
                print(f"✅ {product_name} is likely IN STOCK (found Add to Cart button)")
                return True
            
            # Method 3: Check for price display (products usually show price when in stock)
            price_elements = soup.select('.price, .pdp-price, [data-testid="price"]')
            if price_elements:
                print(f"✅ {product_name} shows price, possibly IN STOCK")
                return True
                
            print(f"⚠️ Couldn't determine stock status for {product_name}")
            return False
        else:
            print(f"❌ Got status code {response.status_code} for {product_name}")
            return False
            
    except Exception as e:
        print(f"Error checking {product_name}: {str(e)}")
        return False

def check_product_api(product_id, product_name):
    """
    Try using Croma's API instead of scraping the website
    """
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
        'Accept': 'application/json',
        'Referer': 'https://www.croma.com/',
    }
    
    # Extract the product ID from the URL (it's the last part after the /p/)
    try:
        # The API endpoint might be something like this (we're guessing based on common patterns)
        api_url = f"https://api.croma.com/products/{product_id}/status"
        
        response = requests.get(api_url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            try:
                data = response.json()
                # The actual response structure will depend on Croma's API
                if 'inStock' in data:
                    in_stock = data['inStock']
                    print(f"{'✅ IN STOCK' if in_stock else '❌ OUT OF STOCK'}: {product_name} (via API)")
                    return in_stock
            except json.JSONDecodeError:
                print(f"Could not parse API response for {product_name}")
        
        print(f"API method failed for {product_name}")
        return None
    except Exception as e:
        print(f"Error with API method for {product_name}: {str(e)}")
        return None

# Alternate method: Use a headless browser
def check_with_selenium(url, product_name):
    """
    Note: This requires additional setup:
    pip install selenium
    pip install webdriver-manager
    """
    try:
        from selenium import webdriver
        from selenium.webdriver.chrome.service import Service
        from selenium.webdriver.chrome.options import Options
        from webdriver_manager.chrome import ChromeDriverManager
        from selenium.webdriver.common.by import By
        
        # Set up Chrome options
        chrome_options = Options()
        chrome_options.add_argument("--headless")  # Run in headless mode
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--window-size=1920,1080")
        chrome_options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36")
        
        # Initialize the driver
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=chrome_options)
        
        # Navigate to the URL
        driver.get(url)
        time.sleep(5)  # Allow time for the page to load
        
        # Save the page source for debugging
        with open(f"{product_name.replace(' ', '_')}_selenium.html", "w", encoding="utf-8") as f:
            f.write(driver.page_source)
        
        # Check for out of stock indicators
        page_text = driver.page_source.lower()
        out_of_stock_indicators = ['out of stock', 'sold out', 'currently unavailable']
        for indicator in out_of_stock_indicators:
            if indicator in page_text:
                print(f"❌ {product_name} is OUT OF STOCK (Selenium)")
                driver.quit()
                return False
        
        # Check for add to cart button
        try:
            add_to_cart_buttons = driver.find_elements(By.CSS_SELECTOR, 'button[data-testid="add-to-cart"], .pdp-button, .buy-button')
            if add_to_cart_buttons:
                print(f"✅ {product_name} is IN STOCK (Selenium)")
                driver.quit()
                return True
        except:
            pass
        
        print(f"⚠️ Couldn't determine stock status for {product_name} (Selenium)")
        driver.quit()
        return False
        
    except Exception as e:
        print(f"Error with Selenium for {product_name}: {str(e)}")
        print("Make sure you have installed selenium and webdriver-manager packages.")
        return None

# Alternative: Try both regular HTTP requests and parse JSON data
def try_both_methods(url, product_name, product_id):
    # Extract product_id from URL if not provided
    if not product_id:
        product_id = url.split('/p/')[1]
    
    # First try API method
    api_result = check_product_api(product_id, product_name)
    if api_result is not None:
        return api_result
    
    # If API fails, try regular method
    return check_product_stock(url, product_name)

print("Checking Vivo phones stock status...\n")

# First phone
vivo_x200_url = "https://www.croma.com/vivo-x200-fe-5g-12gb-ram-256gb-frost-blue-/p/316890"
vivo_x200_id = "316890"
vivo_x200_name = "Vivo X200 FE 5G"

# Second phone
vivo_y300_url = "https://www.croma.com/vivo-y300-5g-8gb-ram-128gb-rom-emerald-green-/p/311901"
vivo_y300_id = "311901"
vivo_y300_name = "Vivo Y300 5G"

# Check using improved method
check_product_stock(vivo_x200_url, vivo_x200_name)
check_product_stock(vivo_y300_url, vivo_y300_name)

# Optional: Try the other methods if the above doesn't work
print("\nAttempting additional methods...\n")
try_both_methods(vivo_x200_url, vivo_x200_name, vivo_x200_id)
try_both_methods(vivo_y300_url, vivo_y300_name, vivo_y300_id)

# Optional: Try with Selenium if you have it installed
try:
    print("\nTrying with Selenium (if installed)...\n")
    check_with_selenium(vivo_x200_url, vivo_x200_name)
    check_with_selenium(vivo_y300_url, vivo_y300_name)
except ImportError:
    print("\nSelenium not installed. To use this method:")
    print("pip install selenium webdriver-manager")
